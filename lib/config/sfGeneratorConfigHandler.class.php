<?php
/*
 * This file is part of the Sift PHP framework.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * sfGeneratorConfigHandler.
 *
 * @package    Sift
 * @subpackage config
 */
class sfGeneratorConfigHandler extends sfYamlConfigHandler {

  /**
   * Executes this configuration handler.
   *
   * @param array $configFiles An array of absolute filesystem path to a configuration file
   *
   * @return string Data to be written to a cache file
   *
   * @throws sfConfigurationException If a requested configuration file does not exist or is not readable
   * @throws sfParseException If a requested configuration file is improperly formatted
   * @throws sfInitializationException If a generator.yml key check fails
   */
  public function execute($configFiles)
  {
    // parse the yaml
    $config = self::parseYamls($configFiles);
    if(!$config)
    {
      return '';
    }

    if(!isset($config['generator']))
    {
      throw new sfParseException(sprintf('Configuration file "%s" must specify a generator section.', isset($configFiles[1]) ? $configFiles[1] : $configFiles[0]));
    }

    $config = $config['generator'];

    if(!isset($config['class']))
    {
      throw new sfParseException(sprintf('Configuration file "%s" must specify a generator class section under the generator section.', isset($configFiles[1]) ? $configFiles[1] : $configFiles[0]));
    }

    foreach(array('fields', 'list', 'edit') as $section)
    {
      if(isset($config[$section]))
      {
        throw new sfParseException(sprintf('Configuration file "%s" can specify a "%s" section but only under the param section.', isset($configFiles[1]) ? $configFiles[1] : $configFiles[0], $section));
      }
    }

    // generate class and add a reference to it
    $generatorManager = new sfGeneratorManager(sfConfig::get('sf_module_cache_dir'));

    // generator parameters
    $generatorParam = (isset($config['param']) ? $config['param'] : array());

    // hack to find the module name (look for the last /modules/ in path)
    preg_match(sprintf('#.*/%s/([^/]+)/#', sfConfig::get('sf_app_module_dir_name')), str_replace('\\', '/', $configFiles[0]), $match);
    $generatorParam['module_name'] = $match[1];

    $generatorParam = self::replaceConstants($generatorParam);

    // compile data
    $retval = "<?php\n" .
            "// auto-generated by sfGeneratorConfigHandler\n" .
            "// date: %s\n%s\n";
    $retval = sprintf($retval, date('Y/m/d H:i:s'), self::getContent($generatorManager, $config['class'], $generatorParam));

    return $retval;
  }

  static public function getContent(sfGeneratorManager $generatorManager, $class, $parameters)
  {
    return $generatorManager->generate($class, $parameters);
  }

  /**
   * Replaces constants for php expressions
   *
   * @param mixed $value
   * @return mixed
   */
  public static function replaceConstants($value)
  {
    if(is_array($value))
    {
      array_walk_recursive($value, create_function('&$value', '$value = sfGeneratorConfigHandler::replaceConstantsForExpressions($value);'));
    }
    else
    {
      $value = sfGeneratorConfigHandler::replaceConstantsForExpressions($value);
    }
    return $value;
  }

  /**
   * Replaces the configuration constants for php expressions:
   *
   * %APP_FOO% => sfPhpExpression('sfConfig::get("app_foo")');
   *
   * @param mixed $value
   * @return sfPhpExpression|mixed
   */
  public static function replaceConstantsForExpressions($value)
  {
    if(is_string($value) && preg_match('/%(.+?)%/', $value, $matches))
    {
      $value = new sfPhpExpression(sprintf('sfConfig::get(\'%s\')', strtolower($matches[1])));
    }
    return $value;
  }

}
